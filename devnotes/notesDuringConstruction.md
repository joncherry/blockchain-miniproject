# notes and random thoughts during the coding process

## a few random thoughts from memory

- We have to figure out how to search the chain before we can evaluate doublespend which is part of validating transactions for new blocks. 
- My transactions for the moment only require the signature of the sender, but what about transactions from the bank user which perhaps should be automated, but then I don't intend to make smart contracts part of this project. For real users I suppose it makes sense that you only need to sign if you are going to lose money.
- I am accepting transactions on a first come first serve basis, and timestamping the block when it is full. That could make the timestamp evaluation for doublespend weird, and perhaps with a live transactions design I would reject transactions requests while each block header proof of work is made.

## more random thoughts

- How do nodes agree on the order that blocks were finished. If node A is mining a block and is interupted by a block with proof of work from another node, but node B is mining a block and doesn't get interupted because of network lag, then node A and node B will disaggree about which block should be built on the previous block. Getting 70% signatures of nodes could help. After a node signs that a block is verified, it could use that block as the previous block, but then what if that block doesn't reach 70% and so is rejected? That could make the node think a rejected block was the previous block, unless it receives the reverted message from the origin node. **Update:** the node will now retry finding POW on the latest prevBlockHash if not signed and accepted by 100% to 70% of the other nodes.
- One approach to keep files from growing so large they are too big to parse would be every 10 blocks are saved as a separate file named with the merkle tree hash at the top of those 10 blocks. Before a file has 10 blocks added, it could just be named latestBlocks.json .. This probably won't really be an issue for a local running test because I won't send that many transactions. It is just a fun way to think about how to do a json local file based database. **Update:** I don't want to append to files while reading from those same files as search functionality, so instead write 1 file per block, then once it is written, only read from it.
- If I use a binary hash tree for the merkle tree (2 nodes under every parent node), then there is a new tree growing until it reaches the same height as the previous tree so that those 2 trees can become the 2 children of the top node. However if I use an interlacing tree (5 nodes, 4 nodes, 3 nodes, 2 nodes, 1 top-node), then every new transaction or every new block can instantly be grafted into the tree, but the tree height is equal to the number leafs at the bottom. Furthermore, the old branches can't be severed for archiving (probably won't sever old branches anyway). I guess I will go with a binary tree and there will be 2 trees until the new tree reaches the same height as the old tree. That means I have to somehow keep the trees in the right order and there is no hash to prove the order. gross. Maybe I could use an updating hash of the 2 trees at whatever height they have, but that probably would get messy quick. I might try it though.
- Due to the fact that there can be a varying number of transactions in a given block, there is no way to really have the blocks and transactions be in the same merkle tree if we want the blocks to be at a consistent height, which is important if we want to use the merkle tree for searching. Merkle trees are intended for verification more than searching, so perhaps I should just implement a different method of searching and not use a merkle tree at all. Merkle trees would be a good way to verify work done by other nodes if our operating node was trying to recover from downtime, but since we don't trust any other node in the network, it would be good to verify everything down to transactions from other nodes. If we bother to verify to the depth of the transactions from other nodes, then the proof of work just prevents DOS attacks / spamming, so it is a good idea to rely on the proof of work incentive and use a merkle tree for verification speed, instead of verifying at depth for every block. Feels odd to go either direction. But on the other hand, the POW incentive may not directly incentivize them to add real transactions from the user that don't go below the user balance if the other nodes never even check that.

---

- I had been thinking that getting signatures from other nodes would be a good step toward maintaining consensus. However, when it comes to competition for which node should be allowed to write a block on the previous block, the extra step makes it too complicated to explain to other people easily. Therefore, I am going to fork the repo and remove the petition for signatures step from my actual submission to the miniproject, so that I don't have to explain how it works right away. **Update:** Actually I am going to keep node signatures as a feature, because it has become a vital piece of how to determine which node found proof of work first in a blockchain model where the node only trusts itself.